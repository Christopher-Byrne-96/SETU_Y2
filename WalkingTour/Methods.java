package WalkingTour;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Methods {


	//======================================================================================================================================================================================
	//Simple method to print the main menu keeping the driver program a little cleaner 
	public static void mainMenu() { //Simple method to print the main menu keeping the driver program a little cleaner 
		System.out.print("Current version of program only supports uploading of one file. Attempting to upload a second file will result in data being overwritten!" + "\r\n" + "\r\n" + "\r\n" + 
						"~# The Walking Tour #~ " + "\r\n" + 
						"| 1 | Upload File" + "\r\n" +
						"| 2 | View Locations" + "\r\n" +
						"| 3 | Add/Search for an edge" + "\r\n" +
						"| 4 | Print 'Adjacency Matrix' representation of the graph" + "\r\n" +
						"| 0 | Exit Program" + "\r\n");
						
	}//End of method mainMenu
	//======================================================================================================================================================================================
	
	
	
	//===============================================================================================================================================================================================
	// A method for creating the locations objects and populating the Adjacency matrix
	// The logic of this method came from searching google for methods on reading a .txt file into java 
	// Brain storming ways to use locations as objects so they can hold more data about the given location
	// lead to the system of checking for an alphabetic character as the first char on the line 
	// this allowed each line to hold the parameters for a new object to be created.
	// While knowing when the first character is not alphabetic allowed us to then start populating the matrix with the data from the file 
	public static void readFile(Locations[] locations, String fileName, String[][] matrix) {
        File file = new File(fileName); 	// Creating the file object to read
        int locationsAdded = 0; 			// Used as a counter for cycling through the array
        int matrixCounter = 0;
        try {
			Scanner scan = new Scanner(file);// Setting up scanner for reading the file
			
			while(scan.hasNextLine()) {		//While loop will run until the entire file has been read
				String data = scan.nextLine(); //Pulling the Line into variable called data
				if(Character.isAlphabetic(data.charAt(0))) { //Checking if the character is alphabetic signifying it is data to create a location object
					String[] seperated = data.split(",");	//Splitting the line into an array of strings to use as parameters for creating the location object
					locations[locationsAdded] = new Locations(seperated[0], Double.parseDouble(seperated[1]), Double.parseDouble(seperated[2])); //Creating the object. Using parse double to convert the string version of lat and long to double
					locationsAdded++; //Incrementing the counter for the next object to created in the array
				}// End of if
				else {  //Here we have established the line does not start with an alpha character and so we know the next values are for the adjacency matrix
					 	String[] values = data.split(" ");
						for(int i = 0; i < locationsAdded; i++) { // Using nested for loops to assign values to the 2d matrix while using parseInt to extract each int from the values array
						     matrix[matrixCounter][i] = values[i];
					}//End of outer for
						matrixCounter++;
				}// End of else
			}// End of while
		} // End of try
        
        // This catch was auto generated by eclipse and not coded coded by us
        catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}//End of catch
	}//End of method readFile
	//========================================================================================================================================
	
	
	
	//========================================================================================================================================
	// Simple method to print out the locations from the array in a numbered list format
	public static void printLocations(Locations[] locations) {
		for(int i=0; i<locations.length; i++) {
			System.out.println("| " + (i+1) + " | " + locations[i].getName());
		}//End of for
	}//End of method printLocations
	//========================================================================================================================================
	
	
	
	//========================================================================================================================================
	//Method to show adjacent nodes and the closest to the search node
	public static void showAdjacentNodes(Locations[] locations, String[][] matrix, int choice) {
		for(int i=0; i<matrix.length; i++) {			
			String x = matrix[choice-1][i];
			int y = Integer.parseInt(x);
			if(y != 0) {
				System.out.println(locations[i].getName() + " is connected to " + locations[choice-1].getName() + "\r\n");
			}//End of if
		}//End of for
		
		//This section will handle the job of finding the closest nodes
		int smallest = Integer.MAX_VALUE; //Using max value to make life easier
		int[] indexList = new int[10]; // Create an array of size 10 as there can not be any more nodes indexes than that
		int storedIndexes = 0; // A counter to count how many indexes we have store
		// This for loop will find the smallest index first 
		for(int i=0; i<matrix.length; i++) {
			int x = Integer.parseInt(matrix[choice-1][i]);
			if(x != 0 && x < smallest) {
				smallest = x;
			}//End if
		}//End for
		
		// This for loop will then search the array again and store all indexes that match smallest
		for(int i=0; i<matrix.length; i++) {
			int x = Integer.parseInt(matrix[choice-1][i]);
			if(x == smallest) {
				indexList[storedIndexes] = i;
				storedIndexes++;
			}//End if
		}//End for
		
		//Printing out the closest node(s) to the search node
		System.out.println("The closest node(s) to " + locations[choice-1].getName() + " are below:");
		for(int i=0; i<storedIndexes; i++) {
			System.out.println(locations[indexList[i]].getName() + " which is just a " + matrix[choice-1][indexList[i]] + " minute walk away" + "\r\n");
		}
	}//End of method showAdjacentNodes
	//========================================================================================================================================
	
	
	
	//========================================================================================================================================
	//Method that checks if an edge exists and if not allows the user to add one
	public static void addSearchEdges(int first, int second, String[][] matrix, Locations[] locations) {
		Scanner scan = new Scanner(System.in); // Set up scanner
		int x = Integer.parseInt(matrix[first-1][second-1]); // Creating an integer from the matrix
		// Checks to see if an edge exists based on the matrix having a weight of non 0
		if(x == 0) {
			// Here we ask if the user wants to add an edge to the matrix
			System.out.println("No Edge exists between " + locations[first-1].getName() + " and " + locations[second-1].getName());
			System.out.println("Would you like to add one? (Y/N)");
			char ans = scan.next().charAt(0);
			Character.toUpperCase(ans);
			if(ans == 'Y') {
				// This code will add the edge to the matrix
				System.out.println("Adding an edge between " + locations[first-1] + " and " + locations[second-1]);
				System.out.println("What is the weight of the edge? (To fit the format please use 2 characters ie; '03' or '12'");
				String weight = scan.nextLine();
				matrix[first-1][second-1] = weight;
				matrix[second-1][first-1] = weight;
				System.out.println("You have added an edge between " + locations[first-1] + " and " + locations[second-1] + " with a weight of " + weight);
				}//end of inner if
		}//End of outer if
		else {
			// If there was an edge it will be displayed here
			System.out.println("An edge exists between " + locations[first-1] + " and " + locations[second-1]);
			System.out.println("The distance between them is a " + matrix[first-1][second-1] + " walk!");
		}
	}//End of class
	//=========================================================================================================================================
	
	
	
	//=========================================================================================================================================
	//Simple method to print more information on the chosen location
	public static void showMore(Locations location) {
		String name = location.getName();//Getting name from given location
		double lng = location.getLng();//Getting Longitude from given location
		double lat = location.getLat();//Getting Latitude from given location
		
		System.out.print("Name       : " + name + "\r\n" + //printing out the information
						 "Longitude  : " + lng + "\r\n" +
						 "Latitude   : " + lat + "\r\n");
	}//End of method showMore
	//=========================================================================================================================================
	
	
	
	//=========================================================================================================================================
	//A method that will print the matrix 
	public static void printMatrix(Locations[] locations, String[][] matrix) {
		int ascii = 65; //Ascii code for the letter A we will use this to print a series of letters for a legend on the adjacency matrix
		System.out.println("Legend for the adjacency matrix :: " + "\r\n");
		for(int i=0; i< locations.length; i++) {
			char asciiChar = (char) ascii; // Converting ascii code to char
			System.out.print(asciiChar + " = " + locations[i].getName() + "\r\n"); //Looping through Locations and printing the names
			ascii++; // Incrementing to the next ascii code for the next letter to be printed
			}
		System.out.println("  AA BB CC DD EE FF GG HH II JJ ");
		int ascii2 = 65; //Again using the ascii code trick followed by a loop which will print out the matrix with letters identifying cols and rows
		for(int x=0; x<matrix.length; x++) {
			char asciiChar2 = (char) ascii2;
			System.out.print(asciiChar2 + " ");
			for(int y=0; y<matrix.length; y++) {
				System.out.print(matrix[x][y] + " ");
				if(y == matrix.length-1) {
					System.out.print("\r\n");
				}//End if
			}//End inner for
			ascii2++;
		}//End outer for
		System.out.println("");
	}//End method printMatrix
	//==========================================================================================================================================
}//End of class
